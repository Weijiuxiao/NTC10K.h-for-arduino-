#include "NTC10K.h" 

//分压电阻为4.7K

//用法：
//1.声明一个NTC10K的类：
// NTC10K T0(A0)
//
//2.主函数中 T = T0.AD_to_temp();

//			（-20°--167°） AD解算参数				
//AD	温度	索引值	百位	 K			b
//965 	-20		0		9		-0.2494		221.46
//896 	-3		1		8		-0.1573		138.42
//794 	13		2		7		-0.1239		111.47
//697 	25		3		6		-0.1133		103.95
//599 	36		4		5		-0.1135		103.99
//494 	48		5		4		-0.1234		108.87
//397 	60		6		3		-0.1467		118.09
//296 	75		7		2		-0.1994		133.49
//197 	95		8		1		0.0013	-0.7403	 189.37   T = 0.0013x² - 0.7403x + 189.37
//98	130		9		0		-0.7758		203.71
//50	167



//***************温度解算参数******************//

float K[10] = {0.2494, 0.1573, 0.1239, 0.1133, 0.1135, 0.1234, 0.1467, 0.1994, 0, 	0.7758};
//斜率 截距值：0       1       2       3       4       5       6       7       8	 9       八号为二项拟合
float b[10] = {221.46, 138.42, 111.47, 103.95, 103.99, 108.87, 118.09, 133.49, 0, 	203.71};
//斜率 截距值：0       1       2       3       4       5       6       7       8     9	 10
int index[11] = {965, 896, 	794, 	697, 	599, 	494, 	397, 	296,	197,	98,  50};


NTC10K::NTC10K(unsigned char AD_pin)
{
	this->Analog_pin=AD_pin;
}

float NTC10K::AD_to_temp()
{
  float T;
  int AD_value;
  char i;
  AD_value = analogRead(this->Analog_pin);
  if(AD_value < index[0] && AD_value > index[10])
  {
	  for(i=0;i<=9;i++)
	  {
		  if(AD_value<=index[i] && AD_value>index[i+1]) //排序
		  {
			  if(i == 8) //特例二项拟合
			  {
				  T = AD_value*AD_value;
				  T = 0.0013*T;
				  T = T+189.37;
				  T = T-0.7403*AD_value;
			  }
			  else{ 	//线性拟合
				  T = b[i] -K[i]*AD_value;
			  }
			  break;  //跳出循环
		  }
	  }
  }
  else{
	 if(AD_value >index[0]) {T = -30;}
	 if(AD_value <=50)		{T = 168;}
  }
  return T;
}

